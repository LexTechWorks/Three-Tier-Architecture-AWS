pipeline {
    /* Executa no node controller ----------------------------------------- */
    agent any

    /* OpÃ§Ãµes -------------------------------------------------------------- */
    options {
        ansiColor('xterm')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
        skipDefaultCheckout(true)
    }

    /* Ferramentas --------------------------------------------------------- */
    tools { terraform 'terraform' }

    /* VariÃ¡veis fÃ¡ceis de ajustar ---------------------------------------- */
    environment {
        TF_BACKEND_BUCKET = 'lextechworks'
        TF_BACKEND_REGION = 'us-east-1'
        TF_DIR = 'Terraform/Environment'
        ANSIBLE_DIR = 'Ansible'
    }

    stages {

        /* ---------- Checkout -------------------------------------------- */
        stage('Checkout') {
            steps { 
                checkout scm 
                
                script {
                    // Mostra estrutura do projeto
                    sh 'pwd && ls -la'
                    dir(env.TF_DIR) {
                        sh 'ls -la'
                    }
                }
            }
        }

        /* ---------- Init ------------------------------------------------ */
        stage('Terraform Init') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'aws-terraform',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        script {
                            if (env.TF_BACKEND_BUCKET?.trim()) {
                                sh """
                                  terraform init \\
                                    -backend-config="bucket=${TF_BACKEND_BUCKET}" \\
                                    -backend-config="region=${TF_BACKEND_REGION}"
                                """
                            } else {
                                sh 'terraform init'
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Fmt & Validate -------------------------------------- */
        stage('Terraform Validate') {
            steps {
                dir(env.TF_DIR) {
                    /* Apenas mostra diferenÃ§as, mas NÃƒO falha o build */
                    sh 'terraform fmt -recursive -diff'
                    sh 'terraform validate'
                }
            }
        }

        /* ---------- Plan ------------------------------------------------ */
        stage('Terraform Plan') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'aws-terraform',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh 'terraform plan -out=tfplan'
                    }
                }
            }
        }

        /* ---------- Apply ----------------------------------------------- */
        stage('Terraform Apply') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'aws-terraform',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh 'terraform apply -auto-approve tfplan'
                        
                        // Captura outputs importantes para o Ansible
                        script {
                            try {
                                env.BASTION_IP = sh(
                                    script: 'terraform output -raw bastion_public_ip',
                                    returnStdout: true
                                ).trim()
                                
                                env.ALB_DNS = sh(
                                    script: 'terraform output -raw alb_dns_name',
                                    returnStdout: true
                                ).trim()
                                
                                echo "âœ… Infraestrutura criada:"
                                echo "   â€¢ Bastion IP: ${env.BASTION_IP}"
                                echo "   â€¢ ALB DNS: ${env.ALB_DNS}"
                                
                            } catch (Exception e) {
                                echo "âš ï¸ NÃ£o foi possÃ­vel capturar alguns outputs: ${e.message}"
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Deploy Ansible ------------------------------------- */
        stage('Deploy via Ansible') {
            when {
                expression { env.BASTION_IP != null && env.BASTION_IP != '' }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'aws-terraform',
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    ),
                    sshUserPrivateKey(
                        credentialsId: 'aws-ssh-key',
                        keyFileVariable: 'SSH_KEY_FILE',
                        usernameVariable: 'SSH_USER'
                    )
                ]) {
                    
                    script {
                        // Aguarda instÃ¢ncias ficarem prontas
                        echo "â³ Aguardando instÃ¢ncias ficarem prontas..."
                        sleep(time: 120, unit: "SECONDS")
                        
                        // Configura SSH
                        sh """
                            echo "ðŸ”‘ Configurando acesso SSH..."
                            mkdir -p ~/.ssh
                            ssh-keyscan -H ${env.BASTION_IP} >> ~/.ssh/known_hosts || true
                        """
                        
                        // Aguarda SSH do Bastion estar disponÃ­vel
                        retry(5) {
                            sh """
                                echo "ðŸ§ª Testando SSH para o Bastion..."
                                ssh -i \${SSH_KEY_FILE} -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'echo "SSH OK"'
                            """
                        }
                        
                        // Copia chave SSH para o Bastion
                        sh """
                            echo "ðŸ“‹ Configurando chaves no Bastion..."
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no \${SSH_KEY_FILE} ubuntu@${env.BASTION_IP}:~/.ssh/id_rsa
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod 600 ~/.ssh/id_rsa'
                        """
                        
                        // Copia arquivos do Ansible para o Bastion
                        sh """
                            echo "ðŸ“‚ Enviando playbooks para o Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'mkdir -p ~/ansible/templates'
                            
                            # Copia arquivos essenciais do Ansible
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/ansible.cfg ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/aws_ec2.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/playbook-nginx.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/test-connectivity.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/templates/* ubuntu@${env.BASTION_IP}:~/ansible/templates/
                            
                            # Copia deploy-docker.yml se existir
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/deploy-docker.yml ubuntu@${env.BASTION_IP}:~/ansible/ || echo "deploy-docker.yml nÃ£o encontrado"
                            
                            # Configurar permissÃµes
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod +x ~/ansible/*.sh 2>/dev/null || true'
                        """
                        
                        // Executa setup e testes no Bastion
                        sh """
                            echo "ðŸ”§ Configurando Ansible no Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} << 'EOF'
                            cd ~/ansible
                            
                            # Configura credenciais AWS no Bastion para inventÃ¡rio dinÃ¢mico
                            export AWS_ACCESS_KEY_ID="\${AWS_ACCESS_KEY_ID}"
                            export AWS_SECRET_ACCESS_KEY="\${AWS_SECRET_ACCESS_KEY}"
                            export AWS_DEFAULT_REGION="us-east-1"
                            
                            # Aguarda instÃ¢ncias de aplicaÃ§Ã£o ficarem prontas
                            echo "â³ Aguardando instÃ¢ncias de aplicaÃ§Ã£o..."
                            sleep 90
                            
                            # Testa inventÃ¡rio dinÃ¢mico AWS
                            echo "ðŸ” Testando inventÃ¡rio dinÃ¢mico AWS..."
                            ansible-inventory -i aws_ec2.yml --list || echo "âš ï¸ InventÃ¡rio dinÃ¢mico falhou"
                            ansible-inventory -i aws_ec2.yml --graph || echo "âš ï¸ Graph do inventÃ¡rio falhou"
                            
                            # Testa conectividade com grupos dinÃ¢micos
                            echo "ðŸ“ Testando conectividade com grupos dinÃ¢micos..."
                            ansible role_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' || \\
                            ansible tier_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' || \\
                            echo "âš ï¸ Conectividade inicial falhou, pode ser normal se instÃ¢ncias ainda estÃ£o inicializando"
                            
                            # Executa teste de conectividade detalhado
                            echo "ðŸ§ª Executando teste de conectividade detalhado..."
                            ansible-playbook test-connectivity.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' || \\
                            echo "âš ï¸ Teste de conectividade falhou - continuando com deploy principal"
                            
                            # Executa playbook principal do Nginx usando inventÃ¡rio dinÃ¢mico
                            echo "ðŸš€ Configurando Nginx nos servidores de aplicaÃ§Ã£o via inventÃ¡rio dinÃ¢mico..."
                            ansible-playbook playbook-nginx.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' -v
EOF
                        """
                    }
                }
            }
        }

        /* ---------- Health Check --------------------------------------- */
        stage('Health Check') {
            when {
                expression { env.ALB_DNS != null && env.ALB_DNS != '' }
            }
            steps {
                script {
                    echo "ðŸ¥ Verificando saÃºde da aplicaÃ§Ã£o..."
                    
                    // Aguarda ALB detectar as instÃ¢ncias
                    sleep(time: 60, unit: "SECONDS")
                    
                    def maxRetries = 15
                    def retryCount = 0
                    def healthy = false
                    
                    while (retryCount < maxRetries && !healthy) {
                        try {
                            // Primeiro testa o endpoint principal
                            def response = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}",
                                returnStdout: true
                            ).trim()
                            
                            if (response == '200') {
                                echo "âœ… AplicaÃ§Ã£o principal estÃ¡ respondendo!"
                                
                                // Agora testa o health check endpoint
                                def healthResponse = sh(
                                    script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}/health",
                                    returnStdout: true
                                ).trim()
                                
                                if (healthResponse == '200') {
                                    echo "âœ… Health check endpoint estÃ¡ funcionando!"
                                    healthy = true
                                } else {
                                    echo "âš ï¸ PÃ¡gina principal OK (${response}), mas health check falhou (${healthResponse})"
                                }
                            } else {
                                echo "âš ï¸ Tentativa ${retryCount + 1}/${maxRetries} - Status da aplicaÃ§Ã£o: ${response}"
                                sleep(time: 20, unit: "SECONDS")
                            }
                        } catch (Exception e) {
                            echo "âš ï¸ Erro no health check: ${e.message}"
                            echo "ðŸ” Tentativa ${retryCount + 1}/${maxRetries}"
                            sleep(time: 20, unit: "SECONDS")
                        }
                        
                        retryCount++
                    }
                    
                    if (!healthy) {
                        echo "âŒ Health check falhou apÃ³s ${maxRetries} tentativas"
                        echo "âš ï¸ Isso pode ser normal se as instÃ¢ncias ainda estÃ£o sendo configuradas"
                        echo "ðŸ” Verifique manualmente: http://${env.ALB_DNS}"
                    }
                }
            }
        }
    }

    /* ---------- PÃ³s-build ---------------------------------------------- */
    post {
        always {
            script {
                dir(env.TF_DIR) {
                    archiveArtifacts artifacts: 'tfplan', fingerprint: true, allowEmptyArchive: true
                }
            }
        }
        
        success {
            echo """
            ðŸŽ‰ Deploy realizado com sucesso!
            
            ðŸ“Š Resumo da Infraestrutura:
            â€¢ Ambiente: prod
            â€¢ Bastion Host: ${env.BASTION_IP ?: 'N/A'}
            â€¢ Load Balancer: ${env.ALB_DNS ?: 'N/A'}
            â€¢ URL da AplicaÃ§Ã£o: http://${env.ALB_DNS ?: 'N/A'}
            
            ðŸ”— Links Ãºteis:
            â€¢ AplicaÃ§Ã£o: http://${env.ALB_DNS ?: 'N/A'}
            â€¢ Health Check: http://${env.ALB_DNS ?: 'N/A'}/health
            â€¢ AWS Console: https://console.aws.amazon.com/
            
            ðŸš€ Para acessar o Bastion:
            ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            
            ðŸ”§ Comandos Ãºteis no Bastion:
            â€¢ ansible-inventory -i aws_ec2.yml --list
            â€¢ ansible role_application -i aws_ec2.yml -m ping
            â€¢ ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            """
        }
        
        failure {
            echo """
            âŒ Deploy falhou!
            
            ðŸ” Para debugar:
            1. Verifique os logs do Jenkins acima
            2. Acesse o Bastion (se disponÃ­vel): ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            3. Verifique logs do Ansible em: ~/ansible/ansible.log
            4. Teste manualmente: cd ~/ansible && ./deploy-manual.sh
            5. Verifique a infraestrutura no AWS Console
            
            ðŸ“‹ Comandos Ãºteis no Bastion:
            â€¢ ansible-inventory -i aws_ec2.yml --list
            â€¢ ansible role_application -i aws_ec2.yml -m ping
            â€¢ ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            â€¢ ansible-playbook test-connectivity.yml -i aws_ec2.yml
            """
        }
    }
}