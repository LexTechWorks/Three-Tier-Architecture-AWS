pipeline {
    /* Executa no node controller ----------------------------------------- */
    agent any

    /* Op√ß√µes -------------------------------------------------------------- */
    options {
        ansiColor('xterm')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
        skipDefaultCheckout(true)
    }

    /* Ferramentas --------------------------------------------------------- */
    tools { terraform 'terraform' }

    /* Vari√°veis f√°ceis de ajustar ---------------------------------------- */
    environment {
        TF_BACKEND_BUCKET = 'lextechworks'
        TF_BACKEND_REGION = 'us-east-1'
        TF_DIR = 'Terraform/Environment'
        ANSIBLE_DIR = 'Ansible'
        // Cache e timeout para provedores Terraform
        TF_PLUGIN_CACHE_DIR = "${WORKSPACE}/.terraform.d/plugin-cache"
        TF_REGISTRY_CLIENT_TIMEOUT = '180'
    }

    stages {

        /* ---------- Checkout -------------------------------------------- */
        stage('Checkout') {
            steps { 
                checkout scm 
                
                script {
                    // Mostra estrutura do projeto
                    sh 'pwd && ls -la'
                    dir(env.TF_DIR) {
                        sh 'ls -la'
                    }
                }
            }
        }

        /* ---------- Init ------------------------------------------------ */
        stage('Terraform Init') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        script {
                            // Garante diret√≥rio de cache de providers
                            sh 'mkdir -p "$TF_PLUGIN_CACHE_DIR"'

                            if (env.TF_BACKEND_BUCKET?.trim()) {
                                retry(3) {
                                    sh """
                                      terraform init \\
                                        -backend-config="bucket=${TF_BACKEND_BUCKET}" \\
                                        -backend-config="region=${TF_BACKEND_REGION}"
                                    """
                                }
                            } else {
                                retry(3) {
                                    sh 'terraform init'
                                }
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Fmt & Validate -------------------------------------- */
        stage('Terraform Validate') {
            steps {
                dir(env.TF_DIR) {
                    /* Apenas mostra diferen√ßas, mas N√ÉO falha o build */
                    sh 'terraform fmt -recursive -diff'
                    sh 'terraform validate'
                }
            }
        }

        /* ---------- Plan ------------------------------------------------ */
        stage('Terraform Plan') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh '''
                            set -e
                            echo "üîß Gerando vari√°veis automaticamente (sem input manual)..."

                            # Caminho padr√£o da chave p√∫blica dentro do workspace
                            PUB_KEY_PATH="$WORKSPACE/Terraform/Environment/aws-key.pub"

                            # Gera par de chaves se n√£o existir
                            if [ ! -f "$PUB_KEY_PATH" ]; then
                              echo "üîë Gerando nova chave SSH..."
                              if command -v ssh-keygen >/dev/null 2>&1; then
                                ssh-keygen -t ed25519 -f "$WORKSPACE/Terraform/Environment/aws-key" -N "" -C "jenkins-auto" || \
                                ssh-keygen -t rsa -b 4096 -f "$WORKSPACE/Terraform/Environment/aws-key" -N "" -C "jenkins-auto"
                              else
                                echo "‚ùå ssh-keygen n√£o encontrado"; exit 1
                              fi
                            fi

                            # Descobre IP p√∫blico do agente para liberar SSH somente a partir dele
                            CURRENT_IP=$( (curl -s --max-time 5 https://checkip.amazonaws.com || curl -s --max-time 5 https://api.ipify.org) | tr -d '\r\n' || true )
                            if [ -z "$CURRENT_IP" ]; then
                              echo "‚ö†Ô∏è N√£o foi poss√≠vel obter IP p√∫blico, usando 0.0.0.0/0 (menos seguro)";
                              ALLOWED_SSH_CIDR="0.0.0.0/0"
                            else
                              ALLOWED_SSH_CIDR="$CURRENT_IP/32"
                            fi

                            DOMAIN_NAME_VALUE="lextechworks.com"

                            cat > terraform.auto.tfvars <<EOF
public_key_path  = "$PUB_KEY_PATH"
allowed_ssh_cidr = "$ALLOWED_SSH_CIDR"
domain_name      = "$DOMAIN_NAME_VALUE"
EOF
                            echo "üìÑ Conte√∫do gerado de terraform.auto.tfvars:" && cat terraform.auto.tfvars

                            terraform plan -out=tfplan
                        '''
                    }
                }
            }
        }

        /* ---------- Apply ----------------------------------------------- */
        stage('Terraform Apply') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh 'terraform apply -auto-approve tfplan'
                        
                        // Captura outputs importantes para o Ansible
                        script {
                            try {
                                env.BASTION_IP = sh(
                                    script: 'terraform output -raw bastion_public_ip',
                                    returnStdout: true
                                ).trim()
                                
                                env.ALB_DNS = sh(
                                    script: 'terraform output -raw alb_dns_name',
                                    returnStdout: true
                                ).trim()
                                
                                echo "‚úÖ Infraestrutura criada:"
                                echo "   ‚Ä¢ Bastion IP: ${env.BASTION_IP}"
                                echo "   ‚Ä¢ ALB DNS: ${env.ALB_DNS}"
                                
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è N√£o foi poss√≠vel capturar alguns outputs: ${e.message}"
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Deploy Ansible ------------------------------------- */
        stage('Deploy via Ansible') {
            when {
                expression { env.BASTION_IP != null && env.BASTION_IP != '' }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'LexTechWorks-AWS',
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    ),
                    sshUserPrivateKey(
                        credentialsId: 'aws-ssh-key',
                        keyFileVariable: 'SSH_KEY_FILE',
                        usernameVariable: 'SSH_USER'
                    )
                ]) {
                    
                    script {
                        // Aguarda inst√¢ncias ficarem prontas
                        echo "‚è≥ Aguardando inst√¢ncias ficarem prontas..."
                        sleep(time: 120, unit: "SECONDS")
                        
                        // Configura SSH
                        sh """
                            echo "üîë Configurando acesso SSH..."
                            mkdir -p ~/.ssh
                            ssh-keyscan -H ${env.BASTION_IP} >> ~/.ssh/known_hosts || true
                        """
                        
                        // Aguarda SSH do Bastion estar dispon√≠vel
                        retry(5) {
                            sh """
                                echo "üß™ Testando SSH para o Bastion..."
                                ssh -i \${SSH_KEY_FILE} -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'echo "SSH OK"'
                            """
                        }
                        
                        // Copia chave SSH para o Bastion
                        sh """
                            echo "üìã Configurando chaves no Bastion..."
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no \${SSH_KEY_FILE} ubuntu@${env.BASTION_IP}:~/.ssh/id_rsa
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod 600 ~/.ssh/id_rsa'
                        """
                        
                        // Copia arquivos do Ansible para o Bastion
                        sh """
                            echo "üìÇ Enviando playbooks para o Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'mkdir -p ~/ansible/templates'
                            
                            # Copia arquivos essenciais do Ansible
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/ansible.cfg ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/aws_ec2.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/playbook-nginx.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/test-connectivity.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/templates/* ubuntu@${env.BASTION_IP}:~/ansible/templates/
                            
                            # Copia deploy-docker.yml
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/deploy-docker.yml ubuntu@${env.BASTION_IP}:~/ansible/ || echo "deploy-docker.yml n√£o encontrado"
                            
                            # Configurar permiss√µes
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod +x ~/ansible/*.sh 2>/dev/null || true'
                        """
                        
                        // Executa setup e testes no Bastion
                        sh """
                            echo "üîß Configurando Ansible no Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} << 'EOF'
                            cd ~/ansible
                            
                            # Configura logs detalhados
                            export ANSIBLE_LOG_PATH="~/ansible/ansible-deploy.log"
                            export ANSIBLE_DEBUG=1
                            
                            # Configura credenciais AWS no Bastion para invent√°rio din√¢mico
                            export AWS_ACCESS_KEY_ID="\${AWS_ACCESS_KEY_ID}"
                            export AWS_SECRET_ACCESS_KEY="\${AWS_SECRET_ACCESS_KEY}"
                            export AWS_DEFAULT_REGION="us-east-1"
                            
                            echo "üìù Log iniciado em \$(date)" | tee -a ~/ansible/deploy.log
                            
                            # Aguarda inst√¢ncias de aplica√ß√£o ficarem prontas
                            echo "‚è≥ Aguardando inst√¢ncias de aplica√ß√£o..." | tee -a ~/ansible/deploy.log
                            sleep 90
                            
                            # Testa invent√°rio din√¢mico AWS
                            echo "üîç Testando invent√°rio din√¢mico AWS..." | tee -a ~/ansible/deploy.log
                            ansible-inventory -i aws_ec2.yml --list 2>&1 | tee -a ~/ansible/inventory.log || echo "‚ö†Ô∏è Invent√°rio din√¢mico falhou" | tee -a ~/ansible/deploy.log
                            ansible-inventory -i aws_ec2.yml --graph 2>&1 | tee -a ~/ansible/inventory.log || echo "‚ö†Ô∏è Graph do invent√°rio falhou" | tee -a ~/ansible/deploy.log
                            
                            # Testa conectividade com grupos din√¢micos
                            echo "üèì Testando conectividade com grupos din√¢micos..." | tee -a ~/ansible/deploy.log
                            ansible role_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' -v 2>&1 | tee -a ~/ansible/connectivity.log || \\
                            ansible tier_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' -v 2>&1 | tee -a ~/ansible/connectivity.log || \\
                            echo "‚ö†Ô∏è Conectividade inicial falhou, pode ser normal se inst√¢ncias ainda est√£o inicializando" | tee -a ~/ansible/deploy.log
                            
                            # Executa teste de conectividade detalhado
                            echo "üß™ Executando teste de conectividade detalhado..." | tee -a ~/ansible/deploy.log
                            ansible-playbook test-connectivity.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' -v 2>&1 | tee -a ~/ansible/test-connectivity.log || \\
                            echo "‚ö†Ô∏è Teste de conectividade falhou - continuando com deploy principal" | tee -a ~/ansible/deploy.log
                            
                            # Executa playbook principal do Nginx usando invent√°rio din√¢mico
                            echo "üöÄ Configurando Nginx nos servidores de aplica√ß√£o via invent√°rio din√¢mico..." | tee -a ~/ansible/deploy.log
                            ansible-playbook playbook-nginx.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' -v 2>&1 | tee -a ~/ansible/nginx-deploy.log
                            
                            echo "üìù Deploy finalizado em \$(date)" | tee -a ~/ansible/deploy.log
                            echo "üìä Resumo dos logs criados:" | tee -a ~/ansible/deploy.log
                            ls -la ~/ansible/*.log | tee -a ~/ansible/deploy.log
EOF
                        """
                    }
                }
            }
        }

        /* ---------- Health Check --------------------------------------- */
        stage('Health Check') {
            when {
                expression { env.ALB_DNS != null && env.ALB_DNS != '' }
            }
            steps {
                script {
                    echo "üè• Verificando sa√∫de da aplica√ß√£o..."
                    
                    // Aguarda ALB detectar as inst√¢ncias
                    sleep(time: 60, unit: "SECONDS")
                    
                    def maxRetries = 15
                    def retryCount = 0
                    def healthy = false
                    
                    while (retryCount < maxRetries && !healthy) {
                        try {
                            // Primeiro testa o endpoint principal
                            def response = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}",
                                returnStdout: true
                            ).trim()
                            
                            if (response == '200') {
                                echo "‚úÖ Aplica√ß√£o principal est√° respondendo!"
                                
                                // Agora testa o health check endpoint
                                def healthResponse = sh(
                                    script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}/health",
                                    returnStdout: true
                                ).trim()
                                
                                if (healthResponse == '200') {
                                    echo "‚úÖ Health check endpoint est√° funcionando!"
                                    healthy = true
                                } else {
                                    echo "‚ö†Ô∏è P√°gina principal OK (${response}), mas health check falhou (${healthResponse})"
                                }
                            } else {
                                echo "‚ö†Ô∏è Tentativa ${retryCount + 1}/${maxRetries} - Status da aplica√ß√£o: ${response}"
                                sleep(time: 20, unit: "SECONDS")
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Erro no health check: ${e.message}"
                            echo "üîç Tentativa ${retryCount + 1}/${maxRetries}"
                            sleep(time: 20, unit: "SECONDS")
                        }
                        
                        retryCount++
                    }
                    
                    if (!healthy) {
                        echo "‚ùå Health check falhou ap√≥s ${maxRetries} tentativas"
                        echo "‚ö†Ô∏è Isso pode ser normal se as inst√¢ncias ainda est√£o sendo configuradas"
                        echo "üîç Verifique manualmente: http://${env.ALB_DNS}"
                    }
                }
            }
        }
    }

    /* ---------- P√≥s-build ---------------------------------------------- */
    post {
        always {
            script {
                dir(env.TF_DIR) {
                    archiveArtifacts artifacts: 'tfplan', fingerprint: true, allowEmptyArchive: true
                }
            }
        }
        
        success {
            echo """
            üéâ Deploy realizado com sucesso!
            
            üìä Resumo da Infraestrutura:
            ‚Ä¢ Ambiente: prod
            ‚Ä¢ Bastion Host: ${env.BASTION_IP ?: 'N/A'}
            ‚Ä¢ Load Balancer: ${env.ALB_DNS ?: 'N/A'}
            ‚Ä¢ URL da Aplica√ß√£o: http://${env.ALB_DNS ?: 'N/A'}
            
            üîó Links √∫teis:
            ‚Ä¢ Aplica√ß√£o: http://${env.ALB_DNS ?: 'N/A'}
            ‚Ä¢ Health Check: http://${env.ALB_DNS ?: 'N/A'}/health
            ‚Ä¢ AWS Console: https://console.aws.amazon.com/
            
            üöÄ Para acessar o Bastion:
            ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            
            üîß Comandos √∫teis no Bastion:
            ‚Ä¢ ansible-inventory -i aws_ec2.yml --list
            ‚Ä¢ ansible role_application -i aws_ec2.yml -m ping
            ‚Ä¢ ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            """
        }
        
        failure {
            echo """
            ‚ùå Deploy falhou!
            
            üîç Para debugar:
            1. Verifique os logs do Jenkins acima
            2. Acesse o Bastion (se dispon√≠vel): ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            3. Verifique logs do Ansible em: ~/ansible/ansible.log
            4. Teste manualmente: cd ~/ansible && ./deploy-manual.sh
            5. Verifique a infraestrutura no AWS Console
            
            üìã Comandos √∫teis no Bastion:
            ‚Ä¢ ansible-inventory -i aws_ec2.yml --list
            ‚Ä¢ ansible role_application -i aws_ec2.yml -m ping
            ‚Ä¢ ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            ‚Ä¢ ansible-playbook test-connectivity.yml -i aws_ec2.yml
            """
        }
    }
}