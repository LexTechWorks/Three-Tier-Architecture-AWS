pipeline {
    /* Executa no node controller ----------------------------------------- */
    agent any

    /* Opções -------------------------------------------------------------- */
    options {
        ansiColor('xterm')
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
        skipDefaultCheckout(true)
    }

    /* Ferramentas --------------------------------------------------------- */
    tools { terraform 'terraform' }

    /* Variáveis fáceis de ajustar ---------------------------------------- */
    environment {
        TF_BACKEND_BUCKET = 'lextechworks'
        TF_BACKEND_REGION = 'us-east-1'
        TF_DIR = 'Terraform/Environment'
        ANSIBLE_DIR = 'Ansible'
        // Cache e timeout para provedores Terraform
        TF_PLUGIN_CACHE_DIR = "${WORKSPACE}/.terraform.d/plugin-cache"
        TF_REGISTRY_CLIENT_TIMEOUT = '180'
    }

    stages {

        /* ---------- Checkout -------------------------------------------- */
        stage('Checkout') {
            steps { 
                checkout scm 
                
                script {
                    // Mostra estrutura do projeto
                    sh 'pwd && ls -la'
                    dir(env.TF_DIR) {
                        sh 'ls -la'
                    }
                }
            }
        }

        /* ---------- Init ------------------------------------------------ */
        stage('Terraform Init') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        script {
                            // Garante diretório de cache de providers
                            sh 'mkdir -p "$TF_PLUGIN_CACHE_DIR"'

                            if (env.TF_BACKEND_BUCKET?.trim()) {
                                retry(3) {
                                    sh """
                                      terraform init \\
                                        -backend-config="bucket=${TF_BACKEND_BUCKET}" \\
                                        -backend-config="region=${TF_BACKEND_REGION}"
                                    """
                                }
                            } else {
                                retry(3) {
                                    sh 'terraform init'
                                }
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Fmt & Validate -------------------------------------- */
        stage('Terraform Validate') {
            steps {
                dir(env.TF_DIR) {
                    /* Apenas mostra diferenças, mas NÃO falha o build */
                    sh 'terraform fmt -recursive -diff'
                    sh 'terraform validate'
                }
            }
        }

        /* ---------- Plan ------------------------------------------------ */
        stage('Terraform Plan') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh '''
                            set -e
                            echo "🔧 Gerando variáveis automaticamente (sem input manual)..."

                            # Caminho padrão da chave pública dentro do workspace
                            PUB_KEY_PATH="$WORKSPACE/Terraform/Environment/aws-key.pub"

                            # Gera par de chaves se não existir
                            if [ ! -f "$PUB_KEY_PATH" ]; then
                              echo "🔑 Gerando nova chave SSH..."
                              if command -v ssh-keygen >/dev/null 2>&1; then
                                ssh-keygen -t ed25519 -f "$WORKSPACE/Terraform/Environment/aws-key" -N "" -C "jenkins-auto" || \
                                ssh-keygen -t rsa -b 4096 -f "$WORKSPACE/Terraform/Environment/aws-key" -N "" -C "jenkins-auto"
                              else
                                echo "❌ ssh-keygen não encontrado"; exit 1
                              fi
                            fi

                            # Descobre IP público do agente para liberar SSH somente a partir dele
                            CURRENT_IP=$( (curl -s --max-time 5 https://checkip.amazonaws.com || curl -s --max-time 5 https://api.ipify.org) | tr -d '\r\n' || true )
                            if [ -z "$CURRENT_IP" ]; then
                              echo "⚠️ Não foi possível obter IP público, usando 0.0.0.0/0 (menos seguro)";
                              ALLOWED_SSH_CIDR="0.0.0.0/0"
                            else
                              ALLOWED_SSH_CIDR="$CURRENT_IP/32"
                            fi

                            DOMAIN_NAME_VALUE="lextechworks.com"

                            cat > terraform.auto.tfvars <<EOF
public_key_path  = "$PUB_KEY_PATH"
allowed_ssh_cidr = "$ALLOWED_SSH_CIDR"
domain_name      = "$DOMAIN_NAME_VALUE"
EOF
                            echo "📄 Conteúdo gerado de terraform.auto.tfvars:" && cat terraform.auto.tfvars

                            terraform plan -out=tfplan
                        '''
                    }
                }
            }
        }

        /* ---------- Apply ----------------------------------------------- */
        stage('Terraform Apply') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: 'LexTechWorks-AWS',
                    usernameVariable: 'AWS_ACCESS_KEY_ID',
                    passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {

                    dir(env.TF_DIR) {
                        sh 'terraform apply -auto-approve tfplan'
                        
                        // Captura outputs importantes para o Ansible
                        script {
                            try {
                                env.BASTION_IP = sh(
                                    script: 'terraform output -raw bastion_public_ip',
                                    returnStdout: true
                                ).trim()
                                
                                env.ALB_DNS = sh(
                                    script: 'terraform output -raw alb_dns_name',
                                    returnStdout: true
                                ).trim()
                                
                                echo "✅ Infraestrutura criada:"
                                echo "   • Bastion IP: ${env.BASTION_IP}"
                                echo "   • ALB DNS: ${env.ALB_DNS}"
                                
                            } catch (Exception e) {
                                echo "⚠️ Não foi possível capturar alguns outputs: ${e.message}"
                            }
                        }
                    }
                }
            }
        }

        /* ---------- Deploy Ansible ------------------------------------- */
        stage('Deploy via Ansible') {
            when {
                expression { env.BASTION_IP != null && env.BASTION_IP != '' }
            }
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'LexTechWorks-AWS',
                        usernameVariable: 'AWS_ACCESS_KEY_ID',
                        passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                    ),
                    sshUserPrivateKey(
                        credentialsId: 'aws-ssh-key',
                        keyFileVariable: 'SSH_KEY_FILE',
                        usernameVariable: 'SSH_USER'
                    )
                ]) {
                    
                    script {
                        // Aguarda instâncias ficarem prontas
                        echo "⏳ Aguardando instâncias ficarem prontas..."
                        sleep(time: 120, unit: "SECONDS")
                        
                        // Configura SSH
                        sh """
                            echo "🔑 Configurando acesso SSH..."
                            mkdir -p ~/.ssh
                            ssh-keyscan -H ${env.BASTION_IP} >> ~/.ssh/known_hosts || true
                        """
                        
                        // Aguarda SSH do Bastion estar disponível
                        retry(5) {
                            sh """
                                echo "🧪 Testando SSH para o Bastion..."
                                ssh -i \${SSH_KEY_FILE} -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'echo "SSH OK"'
                            """
                        }
                        
                        // Copia chave SSH para o Bastion
                        sh """
                            echo "📋 Configurando chaves no Bastion..."
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no \${SSH_KEY_FILE} ubuntu@${env.BASTION_IP}:~/.ssh/id_rsa
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod 600 ~/.ssh/id_rsa'
                        """
                        
                        // Copia arquivos do Ansible para o Bastion
                        sh """
                            echo "📂 Enviando playbooks para o Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'mkdir -p ~/ansible/templates'
                            
                            # Copia arquivos essenciais do Ansible
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/ansible.cfg ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/aws_ec2.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/playbook-nginx.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/test-connectivity.yml ubuntu@${env.BASTION_IP}:~/ansible/
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/templates/* ubuntu@${env.BASTION_IP}:~/ansible/templates/
                            
                            # Copia deploy-docker.yml
                            scp -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ${env.ANSIBLE_DIR}/deploy-docker.yml ubuntu@${env.BASTION_IP}:~/ansible/ || echo "deploy-docker.yml não encontrado"
                            
                            # Configurar permissões
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} 'chmod +x ~/ansible/*.sh 2>/dev/null || true'
                        """
                        
                        // Executa setup e testes no Bastion
                        sh """
                            echo "🔧 Configurando Ansible no Bastion..."
                            ssh -i \${SSH_KEY_FILE} -o StrictHostKeyChecking=no ubuntu@${env.BASTION_IP} << 'EOF'
                            cd ~/ansible
                            
                            # Configura logs detalhados
                            export ANSIBLE_LOG_PATH="~/ansible/ansible-deploy.log"
                            export ANSIBLE_DEBUG=1
                            
                            # Configura credenciais AWS no Bastion para inventário dinâmico
                            export AWS_ACCESS_KEY_ID="\${AWS_ACCESS_KEY_ID}"
                            export AWS_SECRET_ACCESS_KEY="\${AWS_SECRET_ACCESS_KEY}"
                            export AWS_DEFAULT_REGION="us-east-1"
                            
                            echo "📝 Log iniciado em \$(date)" | tee -a ~/ansible/deploy.log
                            
                            # Aguarda instâncias de aplicação ficarem prontas
                            echo "⏳ Aguardando instâncias de aplicação..." | tee -a ~/ansible/deploy.log
                            sleep 90
                            
                            # Testa inventário dinâmico AWS
                            echo "🔍 Testando inventário dinâmico AWS..." | tee -a ~/ansible/deploy.log
                            ansible-inventory -i aws_ec2.yml --list 2>&1 | tee -a ~/ansible/inventory.log || echo "⚠️ Inventário dinâmico falhou" | tee -a ~/ansible/deploy.log
                            ansible-inventory -i aws_ec2.yml --graph 2>&1 | tee -a ~/ansible/inventory.log || echo "⚠️ Graph do inventário falhou" | tee -a ~/ansible/deploy.log
                            
                            # Testa conectividade com grupos dinâmicos
                            echo "🏓 Testando conectividade com grupos dinâmicos..." | tee -a ~/ansible/deploy.log
                            ansible role_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' -v 2>&1 | tee -a ~/ansible/connectivity.log || \\
                            ansible tier_application -i aws_ec2.yml -m ping --ssh-common-args='-o ConnectTimeout=10 -o StrictHostKeyChecking=no' -v 2>&1 | tee -a ~/ansible/connectivity.log || \\
                            echo "⚠️ Conectividade inicial falhou, pode ser normal se instâncias ainda estão inicializando" | tee -a ~/ansible/deploy.log
                            
                            # Executa teste de conectividade detalhado
                            echo "🧪 Executando teste de conectividade detalhado..." | tee -a ~/ansible/deploy.log
                            ansible-playbook test-connectivity.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' -v 2>&1 | tee -a ~/ansible/test-connectivity.log || \\
                            echo "⚠️ Teste de conectividade falhou - continuando com deploy principal" | tee -a ~/ansible/deploy.log
                            
                            # Executa playbook principal do Nginx usando inventário dinâmico
                            echo "🚀 Configurando Nginx nos servidores de aplicação via inventário dinâmico..." | tee -a ~/ansible/deploy.log
                            ansible-playbook playbook-nginx.yml -i aws_ec2.yml --ssh-common-args='-o StrictHostKeyChecking=no' --limit 'role_application:tier_application' -v 2>&1 | tee -a ~/ansible/nginx-deploy.log
                            
                            echo "📝 Deploy finalizado em \$(date)" | tee -a ~/ansible/deploy.log
                            echo "📊 Resumo dos logs criados:" | tee -a ~/ansible/deploy.log
                            ls -la ~/ansible/*.log | tee -a ~/ansible/deploy.log
EOF
                        """
                    }
                }
            }
        }

        /* ---------- Health Check --------------------------------------- */
        stage('Health Check') {
            when {
                expression { env.ALB_DNS != null && env.ALB_DNS != '' }
            }
            steps {
                script {
                    echo "🏥 Verificando saúde da aplicação..."
                    
                    // Aguarda ALB detectar as instâncias
                    sleep(time: 60, unit: "SECONDS")
                    
                    def maxRetries = 15
                    def retryCount = 0
                    def healthy = false
                    
                    while (retryCount < maxRetries && !healthy) {
                        try {
                            // Primeiro testa o endpoint principal
                            def response = sh(
                                script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}",
                                returnStdout: true
                            ).trim()
                            
                            if (response == '200') {
                                echo "✅ Aplicação principal está respondendo!"
                                
                                // Agora testa o health check endpoint
                                def healthResponse = sh(
                                    script: "curl -s -o /dev/null -w '%{http_code}' http://${env.ALB_DNS}/health",
                                    returnStdout: true
                                ).trim()
                                
                                if (healthResponse == '200') {
                                    echo "✅ Health check endpoint está funcionando!"
                                    healthy = true
                                } else {
                                    echo "⚠️ Página principal OK (${response}), mas health check falhou (${healthResponse})"
                                }
                            } else {
                                echo "⚠️ Tentativa ${retryCount + 1}/${maxRetries} - Status da aplicação: ${response}"
                                sleep(time: 20, unit: "SECONDS")
                            }
                        } catch (Exception e) {
                            echo "⚠️ Erro no health check: ${e.message}"
                            echo "🔍 Tentativa ${retryCount + 1}/${maxRetries}"
                            sleep(time: 20, unit: "SECONDS")
                        }
                        
                        retryCount++
                    }
                    
                    if (!healthy) {
                        echo "❌ Health check falhou após ${maxRetries} tentativas"
                        echo "⚠️ Isso pode ser normal se as instâncias ainda estão sendo configuradas"
                        echo "🔍 Verifique manualmente: http://${env.ALB_DNS}"
                    }
                }
            }
        }
    }

    /* ---------- Pós-build ---------------------------------------------- */
    post {
        always {
            script {
                dir(env.TF_DIR) {
                    archiveArtifacts artifacts: 'tfplan', fingerprint: true, allowEmptyArchive: true
                }
            }
        }
        
        success {
            echo """
            🎉 Deploy realizado com sucesso!
            
            📊 Resumo da Infraestrutura:
            • Ambiente: prod
            • Bastion Host: ${env.BASTION_IP ?: 'N/A'}
            • Load Balancer: ${env.ALB_DNS ?: 'N/A'}
            • URL da Aplicação: http://${env.ALB_DNS ?: 'N/A'}
            
            🔗 Links úteis:
            • Aplicação: http://${env.ALB_DNS ?: 'N/A'}
            • Health Check: http://${env.ALB_DNS ?: 'N/A'}/health
            • AWS Console: https://console.aws.amazon.com/
            
            🚀 Para acessar o Bastion:
            ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            
            🔧 Comandos úteis no Bastion:
            • ansible-inventory -i aws_ec2.yml --list
            • ansible role_application -i aws_ec2.yml -m ping
            • ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            """
        }
        
        failure {
            echo """
            ❌ Deploy falhou!
            
            🔍 Para debugar:
            1. Verifique os logs do Jenkins acima
            2. Acesse o Bastion (se disponível): ssh -i ~/.ssh/aws-key ubuntu@${env.BASTION_IP ?: 'N/A'}
            3. Verifique logs do Ansible em: ~/ansible/ansible.log
            4. Teste manualmente: cd ~/ansible && ./deploy-manual.sh
            5. Verifique a infraestrutura no AWS Console
            
            📋 Comandos úteis no Bastion:
            • ansible-inventory -i aws_ec2.yml --list
            • ansible role_application -i aws_ec2.yml -m ping
            • ansible-playbook playbook-nginx.yml -i aws_ec2.yml --limit role_application
            • ansible-playbook test-connectivity.yml -i aws_ec2.yml
            """
        }
    }
}