---
# Playbook para deploy de containers Docker nas instÃ¢ncias de aplicaÃ§Ã£o
- name: Deploy Docker Container to Application Servers
  hosts: role_application, tier_application  # Baseado nas tags do EC2
  become: yes
  gather_facts: yes
  
  vars:
    # ConfiguraÃ§Ã£o para sua imagem no ECR
    aws_account_id: "833371734412"
    aws_region: "us-east-1"
    ecr_repository: "nginx-lextechworks"  # Ajuste para o nome do seu repositÃ³rio
    docker_image: "{{ aws_account_id }}.dkr.ecr.{{ aws_region }}.amazonaws.com/{{ ecr_repository }}"
    docker_tag: "{{ docker_tag | default('latest') }}"
    container_name: "nginx-lextechworks"
    container_port: 80
    host_port: 80
    
  tasks:
    - name: Update system packages (Amazon Linux)
      yum:
        name: '*'
        state: latest
        update_cache: yes
      when: ansible_distribution == 'Amazon'
      
    - name: Update system packages (Ubuntu)
      apt:
        upgrade: dist
        update_cache: yes
        cache_valid_time: 3600
      when: ansible_distribution == 'Ubuntu'
      
    - name: Install Docker (Amazon Linux)
      yum:
        name:
          - docker
          - git
          - awscli
        state: present
      when: ansible_distribution == 'Amazon'
      
    - name: Install Docker (Ubuntu)
      apt:
        name:
          - docker.io
          - git
          - awscli
          - python3-pip
          - python3-docker
        state: present
      when: ansible_distribution == 'Ubuntu'
      
    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
        
    - name: Add ubuntu user to docker group (Ubuntu)
      user:
        name: ubuntu
        groups: docker
        append: yes
      when: ansible_distribution == 'Ubuntu'
        
    - name: Add ec2-user to docker group (Amazon Linux)
      user:
        name: ec2-user
        groups: docker
        append: yes
      when: ansible_distribution == 'Amazon'
        
    - name: Install Docker Python library
      pip:
        name: 
          - docker
          - docker-compose
        executable: pip3
        
    - name: Configure AWS credentials for ECR access
      shell: |
        export AWS_ACCESS_KEY_ID="{{ ansible_env.AWS_ACCESS_KEY_ID }}"
        export AWS_SECRET_ACCESS_KEY="{{ ansible_env.AWS_SECRET_ACCESS_KEY }}"
        export AWS_DEFAULT_REGION="{{ aws_region }}"
      no_log: true
        
    - name: Login to ECR
      shell: |
        aws ecr get-login-password --region {{ aws_region }} | docker login --username AWS --password-stdin {{ aws_account_id }}.dkr.ecr.{{ aws_region }}.amazonaws.com
      environment:
        AWS_ACCESS_KEY_ID: "{{ ansible_env.AWS_ACCESS_KEY_ID }}"
        AWS_SECRET_ACCESS_KEY: "{{ ansible_env.AWS_SECRET_ACCESS_KEY }}"
        AWS_DEFAULT_REGION: "{{ aws_region }}"
      register: ecr_login
      changed_when: false
      
    - name: Pull Docker image
      docker_image:
        name: "{{ docker_image }}"
        tag: "{{ docker_tag }}"
        source: pull
        force_source: yes
      register: pull_result
      
    - name: Stop existing container
      docker_container:
        name: "{{ container_name }}"
        state: stopped
      ignore_errors: yes
      
    - name: Remove existing container
      docker_container:
        name: "{{ container_name }}"
        state: absent
      ignore_errors: yes
      
    - name: Run new container
      docker_container:
        name: "{{ container_name }}"
        image: "{{ docker_image }}:{{ docker_tag }}"
        state: started
        restart_policy: always
        ports:
          - "{{ host_port }}:{{ container_port }}"
        env:
          ENVIRONMENT: "{{ ansible_ec2_tag_Environment | default('prod') }}"
          SERVER_NAME: "{{ ansible_hostname }}"
        volumes:
          - /var/log/nginx:/var/log/nginx
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:{{ container_port }}/health"]
          interval: 30s
          timeout: 10s
          retries: 3
          start_period: 40s
      register: container_result
      
    - name: Wait for container to be healthy
      wait_for:
        port: "{{ host_port }}"
        host: "{{ ansible_default_ipv4.address }}"
        delay: 10
        timeout: 60
        
    - name: Verify container is running
      docker_container_info:
        name: "{{ container_name }}"
      register: container_info
      
    - name: Display container status
      debug:
        msg: |
          âœ… Container Deploy Success!
          
          ðŸ“Š Status Details:
          â€¢ Container Status: {{ container_info.container.State.Status }}
          â€¢ Container Health: {{ container_info.container.State.Health.Status | default('N/A') }}
          â€¢ Image: {{ container_info.container.Config.Image }}
          â€¢ Ports: {{ container_info.container.NetworkSettings.Ports }}
          â€¢ Server: {{ ansible_hostname }}
          â€¢ IP: {{ ansible_default_ipv4.address }}
          
    - name: Test HTTP response
      uri:
        url: "http://{{ ansible_default_ipv4.address }}:{{ host_port }}"
        method: GET
        status_code: 200
      retries: 5
      delay: 10
      register: http_test
      
    - name: Test health endpoint
      uri:
        url: "http://{{ ansible_default_ipv4.address }}:{{ host_port }}/health"
        method: GET
        status_code: 200
      retries: 5
      delay: 10
      ignore_errors: yes
      register: health_test
      
    - name: Display test results
      debug:
        msg: |
          ðŸ§ª Connectivity Tests:
          â€¢ HTTP Test: {{ 'PASSED' if http_test.status == 200 else 'FAILED' }}
          â€¢ Health Check: {{ 'PASSED' if health_test.status == 200 else 'FAILED' }}
          â€¢ Access URL: http://{{ ansible_default_ipv4.address }}:{{ host_port }}
        method: GET
        status_code: 200
      retries: 3
      delay: 5
      ignore_errors: yes
      
    - name: Clean up old Docker images
      docker_prune:
        images: yes
        images_filters:
          dangling: false
        containers: yes
        
  handlers:
    - name: restart docker
      systemd:
        name: docker
        state: restarted
